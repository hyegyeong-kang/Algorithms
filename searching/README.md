*탐색 알고리즘*
1. Linear Search Algorithm
2. Binary Search Algorithm<br/>
1, 2 번의 전제조건은 어떤 데이터가 어느 index에 들어있는지 전혀 모르는 상태에서 검색 시작
3. Binary Search Tree; BST 
4. Hash Search Algorithm


## Linear Search Algorithm (선형 탐색)
 - 가장 기초가 되는 알고리즘으로 맨 앞이나, 맨 뒤부터 순서대로 하나하나 찾아보는 알고리즘
 - 구현하기 쉽지만 배열의 크기가 커질수록 찾는 시간 오래 걸림

1. 처음부터 하나하나 원하는 값을 찾아본다.
2. 원하는 값을 찾으면 탐색을 종료한다.

### 시간 복잡도
길이 n 짜리의 리스트를 탐색할 때
Best: 리스트의 첫 번째 원소가 정답인 경우 -> O(1)<br/>
Worst: 리스트의 맨 마지막 원소가 정답이거나, 리스트에 정답이 없을 때 -> O(n)
// 리스트의 크기가 커질수록 시간복잡도 선형적으로 증가함

## Binary Search Algorithm (이진 탐색)
- 중간 지점을 기준으로 데이터를 반씩 나눠서 탐색하는 알고리즘

1. 중간 지점을 선택한 뒤, 중간 지점을 기준으로 왼쪽 혹은 오른쪽 부분만 남긴다. 
2. 남긴 부분 중에서 다시 중간 지점을 선택한 뒤, 왼쪽 혹은 오른쪽만 남긴다.
3. 위 과정을 원하는 값을 찾을 때 까지 반복한다.

### 시간 복잡도
Best: 리스트의 중간 부분이 정답일 때 -> O(1)<br/>
Worst: 리스트에 정답이 없는 경우 -> O(logn)
// 리스트의 크기가 커져도 시간 복잡도가 아주 천천히 증가한다.

<이진탐색을 위한 조건>
1. 원소가 정렬되어있어야 함 (오름차든 내림차든)
2. 원소의 Random Access 가 가능해야 한다.


## Binary Search Tree (이진 탐색 트리)
트리의 한 종류이자 이진 탐색을 위한 방법 중 하나.
이진 탐색은 리스트를 사용하기 때문에 자료의 삽입/삭제가 매우 비효율적이다.
이진 탐색 트리는 트리를 이용하기 때문에 자료의 삽입/삭제가 효율적이다.

1. 이진 탐색 트리 만들기
2. 루트 노트에서 내려가면서 원하는 원소 찾기 (노드 기준으로 왼쪽이 작은 값 오른쪽이 큰 값)
3. 삭제 및 삽입하기 


### 시간 복잡도
|  | 시간복잡도 | 예시(노드의 갯수가 N 일 때) |
| ---- | ------- | ------ |
| Best | O(logn) | 완전 이진트리 |
| Average | O(nlogn) | |
| Worst | O(N) | 한쪽으로 치우친 상태 -> 탐색, 삽입, 삭제할 때 최대 리프 노드까지 내려가면서 진행되어야 함(linked list 와 동일한 성능) |


노드의 갯수가 N 일 때 트리의 높이는 완전 이진 트리(best)일 경우 logN 이고 한쪽으로 치우친 상태(worst)는 N이다.<br/>
탐색, 삽입, 삭제할 때 최대 리프 노드까지 내려가면서 진행되므로 모두 O(logN) 이다.

## Hash Search Algorithm (해시 탐색)
해시탐색은 데이터의 내용과 저장한 곳의 index 를 미리 연결해 줌으로써 짧은 시간에 탐색할 수 있도록 고안된 알고리즘이다.

### 시간 복잡도
Best:
Worst: 
