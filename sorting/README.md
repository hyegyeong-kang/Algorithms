## 버블정렬 - BubbleSort.java 참고
|  | 시간복잡도 |
| ---- | ------- |
| Best | O(nlogn) |
| Average | O(nlogn) |
| Worst | O(n2) |

- 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 인접한 두 개의 레코드를 비교하여 크기가 순서대로 되어있지 않으면 서로 교환한다.
- 첫번째 자료와 두번째 자료를, 두번째 자료와 세번째 자료를,,,(마지막 - 1) 번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- 1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외된다. 
- 이렇게 제외되는 데이터가 하나씩 늘어남.


## 선택 정렬 - SelectionSort.java 참고
|  | 시간복잡도 |
| ---- | ------- |
| Best | O(n^2) |
| Average | O(n^2) |
| Worst | O(n^2) |

- 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고,
- 두 번째 자료를 세 번째 자료부터 마지막 자료까지 차례대로 비교하여 그 중 가장 작은 값을 찾아 두번째 위치에 놓는 과정을 반복하여 정렬 수행한다.
- 1회전을 수행하고 나면 가장 작은 값의 자료가 맨 앞에 오게 되므로 그 다음 회전에서는 두 번째 자료를 가지고 비교한다.

## 삽입정렬 - InsertionSort.java 참고
|  | 시간복잡도 |
| ---- | ------- |
| Best | O(n) |
| Average | O(n^2) |
| Worst | O(n^2) |

- 두 번째 요소부터 시작하여 그 앞의 요소들과 대소 비교하여 삽입할 위치를 지정한 후 삽입할 위치 이후의 요소들을 한 칸씩 미루면서 삽입하는 정렬 알고리즘

## 힙정렬 - HeapSort.java 참고
|  | 시간복잡도 |
| ---- | ------- |
| Best | O(nlogn) |
| Average | O(nlogn) |
| Worst | O(nlogn) |

 힙: 완전 이진트리의 일종으로 우선순위 큐를 위해서 만들어진 자료구조   최대값, 최소값을 쉽게 추출할 수 있는 자료구조다.
- 최소 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법
- 힙은 1차원 배열로 쉽게 구현될 수 있다.
- 정렬해야 할 n개의 요소들을 1차원 배열에 기억한 후 최대 힙 삽입을 통해 차례대로 삽입한다.
- 최대 힙으로 구성된 배열에서 최대값부터 삭제한다.

 
## 병합정렬 - MergeSort.java 참고
|  | 시간복잡도 |
| ---- | ------- |
| Best | O(nlogn) |
| Average | O(nlogn) |
| Worst | O(nlogn) |

 : 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법

- 리스트의 길이가 0 또는 1 이면 이미 정렬된 것으로 본다.
- 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
- 각 부분 리스트를 재귀적으로 합병정렬을 이용해 정렬한다.
- 두 부분의 리스트를 다시 하나의 정렬된 리스트로 합병한다.

** 추가적인 리스트가 필요함<br/>
** 사실상 리스트를 분할하는 일은 시간 복잡도가 없다. 이미 나누어져있는 것이라 생각해도 무관

## 퀵정렬 - QuickSort.java 참고
|  | 시간복잡도 |
| ---- | ------- |
| Best | O(nlogn) |
| Average | O(nlogn) |
| Worst | O(n^2) |

- 기준이 되는 pivot 을 리스트에서 임의로 하나를 선택한다.
'pivot 보다 작은 수' < pivot < 'pivot 보다 큰 수'
나누고 나누어진 부분을 다시 퀵정렬을 사용해 정렬한다.

1. pivot 을 하나 선택한다.
2. pivot 을 기준으로 양쪽에서 피벗보다 큰 값, 혹은 작은 값을 찾는다. 
왼쪽에서부터는 피벗보다 큰 값을 찾고 오른쪽에서는 피벗보다 작은 값을 찾는다.
3. 양 방향에서 찾은 두 원소를 교환한다.
4. 왼쪽에서 탐색하는 위치와 오른쪽에서 탐색하는 위치가 엇갈라지 않을 때 까지 2번으로 돌아가 위 과정을 반복한다.
5. 엇갈린 기점을 기준으로 두 개의 부분 리스트로 나누어 1번으로 돌아가 해당 부분 리스트의 길이가 1이 아닐 때 까지 1번 과정을 반복한다. (divide 분할 과정)
6. 인전한 부분 리스크끼리 합친다. (conqure 정복 과정)

## Tim Sort
- 현실 데이터를 종류와 상관없이 최적으로 정렬을 잘 수행하기 위해서 개발된 방식
: insertion sort + merge sort

- 일정 사이즈의 부분 리스트를 얻고 각각의 부분리스트들에 대해 삽입정렬을 수행하여 정렬을 하고, 정렬된 부분리스트들을 다시 합치는 방식을 사용함

정렬 알고리즘에서 성능에 미치는 원인
1. 비교 및 스왑을 위한 반복자(loop) - 반복자가 어떻게 구현되어있는가의 문제 (시간복잡도)
2. 유효접근시간 (지역성)
3. 메모리 소비량 


1번은 위에 정리해둔 시간 복잡도를 참고하면 될 것같고

2번의 경우에는 CPU에서 참조하는 주소를 읽어들이는데 얼마나 소요되는가를 말한다.
(지역성 원리 잘 따르는지)
 
프로세서가 매번 메인 메모리에 접근해 데이터를 받아오면 시간이 오래 걸리기 때문에 캐시(Cache)에 자주 참조되는 데이터를 담아두고, 해당 데이터가 필요할 때 메인 메모리 대신 캐시에 접근하도록해 처리 속도를 높인다.
 
그러면 캐시를 어떻게 효율적으로 관리하느냐의 문제인데, 결국 캐시에 들어있는 데이터가 얼마나 쓸모있는 데이터가 담겨져 있느냐에 따라 성능이 좌우된다. 이를 적중률(Hit-rate)이라고 하는데, 이러한 적중률을 높이기 위한 메커니즘으로는 크게 3가지(혹은 2가지)로 볼 수 있다.
1. 공간 지역성 (군집화(밀도) 정도, 즉, 최근에 접근한 데이터의 주변 공간에 다시 접근하는 경향이 강할 수록 적중률이 높음)
2. 시간 지역성 (최근 접근한 데이터에 다시 접근하는 경향이 높을 수록 적중률이 높음)
3. 순차 지역성 (데이터가 연속적(순차적)으로 접근하려는 경향이 강할 수록 적중률이 높음. 이를 공간 지역성에 포함시키기도 한다)
 
위와같은 이유로 같은 시간복잡도를 가지는 O(NlogN) 의 정렬 알고리즘 중 HeapSort 보다 Quick Sort 가 더 빠르다는 것이 설명된다.
-> Heap 은 정렬을 위해 하위 트리부터 루트 트리까지 Heap 을 만족하도록 해야하기 때문에 이동하지 않아도 될 불필요한 요소들도 교체될 가능성이 큼
-> Quick 은 피벗을 기준으로 양쪽에서 순차적으로 접근하면서 데이터를 비교하기 때문에 지역성이 높고 불필요한 교환이 일어나지 않는다. 


- 이진 삽입 정렬은 O(N^2) 알고리즘인데 왜 사용하는 것일까?
-> 이미 정렬된 상태에서는 O(N) 의 시간 복잡도를 갖고 
매우 작은 리스트에서는 O(NlogN) 정렬알고리즘 못지않게 빠른 정렬 수행속도를 보이기 때문

![시간복잡도](/sorting/resources/timeComplexity.png)